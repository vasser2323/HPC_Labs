# Vas_Vector_Sum

Задание: реализовать алгоритм сложения элементов вектора 
Входные данные: Вектор размером 1000 - 1000000 значений 
Выходные данные: Сумма элементов вектора + время вычисления

  Каждый поток использует функцию atomicAdd для атомарного сложения своего элемента к общей переменной local_sum. Это гарантирует, что не будет возникать гонок данных при одновременном доступе несколькоих потоков.

  tid - вычисляет уникальный идентификатор потока (thread ID) на основе индекса потока внутри блока (threadIdx.x) и индекса блока (blockIdx.x) умноженного на количество потоков в блоке
  Далее запускается цикл в котором каждый поток будет обрабатывать часть элементов массива. Каждый поток добавляет значение из массива к своей локальной сумме.
  Далее tid += blockDim.x * gridDim.x; - увеличивает tid на значение, равное произведению количества потоков в блоке на количество блоков, что позволяет каждому потоку обрабатывать разные жлементы массива.

  Получившиеся значения:


![image](https://github.com/vasser2323/Vas_Vector_Sum/assets/73202398/8f155287-c9b2-4292-a2bd-98363411d47f)

  
  Приведены 2 графика Ускорения и времени сложения значений на CPU и GPU 
  
  ![image](https://github.com/vasser2323/Vas_Vector_Sum/assets/73202398/612b0485-0a85-4a82-8667-39e32c1d4660)

  ![image](https://github.com/vasser2323/Vas_Vector_Sum/assets/73202398/fd7f6d0b-fe99-4dd6-9a2c-b838a9918921)

  Вывод:
    Меньшее количество вычислений происходит быстрее на CPU, до 50 млн значений, CPU выдавал лучшую скорость, но после GPU стала вычислять быстрее. Параллельное выполнение операции сложения элементов вектора на GPU с использованием CUDA позволяет использовать мощности параллельной обработки GPU для ускорения вычислений в сравнении с последовательным выполнением на CPU.
  

