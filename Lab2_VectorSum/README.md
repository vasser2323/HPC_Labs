#Vas_Vector_Sum

Задание: реализовать алгоритм сложения элементов вектора 
Входные данные: Вектор размером 1000 - 1000000 значений 
Выходные данные: Сумма элементов вектора + время вычисления

  Каждый поток использует функцию atomicAdd для атомарного сложения своего элемента к общей переменной local_sum. Это гарантирует, что не будет возникать гонок данных при одновременном доступе несколькоих потоков.

  tid - вычисляет уникальный идентификатор потока (thread ID) на основе индекса потока внутри блока (threadIdx.x) и индекса блока (blockIdx.x) умноженного на количество потоков в блоке
  Далее запускается цикл в котором каждый поток будет обрабатывать часть элементов массива. Каждый поток добавляет значение из массива к своей локальной сумме.
  Далее tid += blockDim.x * gridDim.x; - увеличивает tid на значение, равное произведению количества потоков в блоке на количество блоков, что позволяет каждому потоку обрабатывать разные жлементы массива.

  Получившиеся значения:

![image](https://github.com/vasser2323/HPC_Labs/assets/73202398/edeee0ff-d9a1-405a-8902-deae90ff281a)

  Приведены 2 графика Ускорения и времени сложения значений на CPU и GPU 
  
![image](https://github.com/vasser2323/HPC_Labs/assets/73202398/41896ff2-de00-4355-83f6-af485e380198)

![image](https://github.com/vasser2323/HPC_Labs/assets/73202398/0c811852-5898-4995-a2cd-bfd0ce1444b1)

  Вывод:
    Меньшее количество вычислений происходит быстрее на CPU, до 50 млн значений, CPU выдавал лучшую скорость, но после GPU стала вычислять быстрее. Параллельное выполнение операции сложения элементов вектора на GPU с использованием CUDA позволяет использовать мощности параллельной обработки GPU для ускорения вычислений в сравнении с последовательным выполнением на CPU.
  

